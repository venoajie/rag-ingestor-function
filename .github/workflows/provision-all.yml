
name: 'Provision Full Application Stack (Manual)'

on:
  workflow_dispatch:

env:
  APP_NAME: "app-rag"
  FUNCTION_NAME: "rag-ingestor"

jobs:
  provision-stack:
    runs-on: ubuntu-latest
    steps:
    - name: 1. Check out repository
      uses: actions/checkout@v4

    - name: 2. Configure OCI CLI
      run: |
        pip install --upgrade oci-cli jq
        mkdir -p ~/.oci
        printf "%s\n" "${{ secrets.OCI_PRIVATE_KEY_CONTENT }}" > ~/.oci/oci_api_key.pem
        echo "[DEFAULT]" > ~/.oci/config
        echo "user=${{ secrets.OCI_USER_OCID }}" >> ~/.oci/config
        echo "fingerprint=${{ secrets.OCI_FINGERPRINT }}" >> ~/.oci/config
        echo "tenancy=${{ secrets.OCI_TENANCY_OCID }}" >> ~/.oci/config
        echo "region=${{ secrets.OCI_REGION }}" >> ~/.oci/config
        echo "key_file=~/.oci/oci_api_key.pem" >> ~/.oci/config
        chmod 600 ~/.oci/oci_api_key.pem ~/.oci/config

    - name: 3. Log in to OCI Container Registry (OCIR)
      uses: docker/login-action@v3
      with:
        registry: ${{ secrets.OCI_REGION_KEY }}.ocir.io
        username: ${{ secrets.OCIR_USERNAME }}
        password: ${{ secrets.OCIR_AUTH_TOKEN }}

    - name: 4. Build and Push Docker Image
      run: |
        REPO_NAME=$(echo "${{ env.APP_NAME }}/${{ env.FUNCTION_NAME }}" | tr '[:upper:]' '[:lower:]')
        IMAGE_TAG="${{ secrets.OCI_REGION_KEY }}.ocir.io/${{ secrets.OCI_NAMESPACE }}/${REPO_NAME}:${{ github.sha }}"
        echo "FULL_IMAGE_NAME=$IMAGE_TAG" >> $GITHUB_ENV
        docker build -t "$IMAGE_TAG" .
        docker push "$IMAGE_TAG"

    - name: 5a. Ensure Service Gateway Route for Private Subnet
      run: |
        set -e
        echo "Ensuring route table for private subnet has a Service Gateway route..."
        
        SUBNET_DETAILS=$(oci network subnet get --subnet-id "${{ secrets.PRIVATE_SUBNET_OCID }}")
        ROUTE_TABLE_OCID=$(echo "$SUBNET_DETAILS" | jq -r '.data."route-table-id"')
        VCN_OCID=$(echo "$SUBNET_DETAILS" | jq -r '.data."vcn-id"')
        VCN_DETAILS=$(oci network vcn get --vcn-id "$VCN_OCID")
        VCN_COMPARTMENT_OCID=$(echo "$VCN_DETAILS" | jq -r '.data."compartment-id"')
        
        if [ "$ROUTE_TABLE_OCID" == "null" ] || [ "$VCN_OCID" == "null" ] || [ "$VCN_COMPARTMENT_OCID" == "null" ]; then
          echo "Error: Could not determine Route Table, VCN, or VCN Compartment OCID."
          exit 1
        fi
        
        SERVICE_GATEWAY_OCID=$(oci network service-gateway list --compartment-id "$VCN_COMPARTMENT_OCID" --vcn-id "$VCN_OCID" --query "data[0].id" --raw-output || true)
        if [ -z "$SERVICE_GATEWAY_OCID" ]; then
            echo "Error: No Service Gateway found in VCN ${VCN_OCID}. A Service Gateway is required."
            exit 1
        fi

        # --- REFACTOR: Query for the Service OCID, not its CIDR block ---
        # The correct 'destination' for this type of route rule is the service's OCID.
        SERVICE_OCID=$(oci network service list --query "data[?name=='${{ secrets.OCI_SERVICES_NETWORK_NAME }}'].id | [0]" --raw-output)
        
        if [ -z "$SERVICE_OCID" ] || [ "$SERVICE_OCID" == "null" ]; then
            echo "Error: Could not find the OCID for the service name provided in the OCI_SERVICES_NETWORK_NAME secret. Please verify the secret's value."
            exit 1
        fi
        echo "Successfully discovered OCI Service OCID: $SERVICE_OCID"

        CURRENT_RULES=$(oci network route-table get --route-table-id "$ROUTE_TABLE_OCID" --query "data.\"route-rules\"")
        # The check remains the same: we only care if a rule to the SGW exists.
        RULE_EXISTS=$(echo "$CURRENT_RULES" | jq --arg sgw_ocid "$SERVICE_GATEWAY_OCID" 'map(select(."network-entity-id" == $sgw_ocid)) | length')

        if [ "$RULE_EXISTS" -gt 0 ]; then
          echo "Service Gateway route already exists. No changes needed."
        else
          echo "Service Gateway route not found. Adding it to the route table..."
          
          # --- REFACTOR: Construct the route rule using the correct API properties ---
          # Use 'destination' (the service OCID) and 'destinationType', not 'cidrBlock'.
          NEW_RULE=$(jq -n \
            --arg dest_ocid "$SERVICE_OCID" \
            --arg sgw_ocid "$SERVICE_GATEWAY_OCID" \
            '{
              "destination": $dest_ocid,
              "destinationType": "SERVICE_CIDR_BLOCK",
              "networkEntityId": $sgw_ocid,
              "description": "Route to OCI Services via Service Gateway (Managed by CI/CD)"
            }')
            
          UPDATED_RULES=$(echo "$CURRENT_RULES" | jq --argjson rule "$NEW_RULE" '. + [$rule]')
          oci network route-table update --route-table-id "$ROUTE_TABLE_OCID" --route-rules "$UPDATED_RULES" --force
          echo "Successfully added Service Gateway route to table ${ROUTE_TABLE_OCID}."
        fi
        
    - name: 5b. Create or Recreate OCI Function Application in Private Subnet
      run: |
        set -e
        echo "Checking for existing application '${{ env.APP_NAME }}'..."
        APP_OCID=$(oci fn application list --compartment-id ${{ secrets.OCI_COMPARTMENT_OCID }} --display-name "${{ env.APP_NAME }}" --query "data[0].id" --raw-output || true)
        CREATE_APP=false
        if [ -z "$APP_OCID" ] || [ "$APP_OCID" == "null" ]; then
          echo "Application not found. It will be created."
          CREATE_APP=true
        else
          echo "Application found with OCID: $APP_OCID. Verifying its subnet configuration..."
          CURRENT_SUBNET_OCID=$(oci fn application get --application-id "$APP_OCID" --query "data.\"subnet-ids\"[0]" --raw-output)
          if [ "$CURRENT_SUBNET_OCID" == "${{ secrets.PRIVATE_SUBNET_OCID }}" ]; then
            echo "Application is already configured with the correct private subnet. No changes needed."
          else
            echo "Application is in the wrong subnet ($CURRENT_SUBNET_OCID). Deleting it to be recreated."
            oci fn application delete --application-id "$APP_OCID" --force
            echo "Deletion complete. Application will be recreated."
            CREATE_APP=true
          fi
        fi
        if [ "$CREATE_APP" = true ]; then
          echo "Creating application in the designated PRIVATE function subnet..."
          SUBNET_IDS='["${{ secrets.PRIVATE_SUBNET_OCID }}"]'
          oci fn application create --compartment-id ${{ secrets.OCI_COMPARTMENT_OCID }} --display-name "${{ env.APP_NAME }}" --subnet-ids "$SUBNET_IDS"
        fi

    - name: 6. Create or Update OCI Function
      env:
        DB_SECRET_OCID: ${{ secrets.DB_SECRET_OCID }}
        OCI_NAMESPACE: ${{ secrets.OCI_NAMESPACE }}
      run: |
        # ... (script content is correct and remains the same)
        echo "Checking for existing function '${{ env.FUNCTION_NAME }}'..."
        APP_OCID=$(oci fn application list --compartment-id ${{ secrets.OCI_COMPARTMENT_OCID }} --display-name "${{ env.APP_NAME }}" --query "data[0].id" --raw-output || true)
        FUNCTION_OCID=$(oci fn function list --application-id "$APP_OCID" --display-name "${{ env.FUNCTION_NAME }}" --query "data[0].id" --raw-output || true)
        JSON_CONFIG=$(jq -n --arg fn_auth "resource_principal" --arg db_secret "$DB_SECRET_OCID" --arg namespace "$OCI_NAMESPACE" '{"FN_AUTH_METHOD": $fn_auth, "DB_SECRET_OCID": $db_secret, "OCI_NAMESPACE": $namespace}')
        if [ -z "$FUNCTION_OCID" ] || [ "$FUNCTION_OCID" == "null" ]; then
          echo "Function not found. Creating it..."
          oci fn function create --application-id "$APP_OCID" --display-name "${{ env.FUNCTION_NAME }}" --image "${{ env.FULL_IMAGE_NAME }}" --memory-in-mbs 1024 --timeout-in-seconds 120 --config "$JSON_CONFIG"
        else
          echo "Function found. Updating it..."
          oci fn function update --function-id "$FUNCTION_OCID" --image "${{ env.FULL_IMAGE_NAME }}" --config "$JSON_CONFIG" --force
        fi

    - name: 7. Wait for IAM Propagation
      run: |
        echo "Waiting 60 seconds for IAM service to recognize the new/updated function..."
        sleep 60
        echo "Cooldown complete."