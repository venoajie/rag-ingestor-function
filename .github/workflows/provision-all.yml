
name: 'Provision Full Application Stack (Manual)'

on:
  workflow_dispatch:

env:
  APP_NAME: "app-rag"
  FUNCTION_NAME: "rag-ingestor"
  NSG_NAME: "rag-app-fn-nsg"

jobs:
  provision-stack:
    runs-on: ubuntu-latest
    steps:
    - name: 1. Check out repository
      uses: actions/checkout@v4

    - name: 2. Configure OCI CLI
      run: |
        pip install --upgrade oci-cli jq
        mkdir -p ~/.oci; printf "%s\n" "${{ secrets.OCI_PRIVATE_KEY_CONTENT }}" > ~/.oci/oci_api_key.pem
        echo "[DEFAULT]" > ~/.oci/config; echo "user=${{ secrets.OCI_USER_OCID }}" >> ~/.oci/config
        echo "fingerprint=${{ secrets.OCI_FINGERPRINT }}" >> ~/.oci/config; echo "tenancy=${{ secrets.OCI_TENANCY_OCID }}" >> ~/.oci/config
        echo "region=${{ secrets.OCI_REGION }}" >> ~/.oci/config; echo "key_file=~/.oci/oci_api_key.pem" >> ~/.oci/config
        chmod 600 ~/.oci/oci_api_key.pem ~/.oci/config

    - name: 3. Log in to OCI Container Registry (OCIR)
      uses: docker/login-action@v3
      with:
        registry: ${{ secrets.OCI_REGION_KEY }}.ocir.io
        username: ${{ secrets.OCIR_USERNAME }}
        password: ${{ secrets.OCIR_AUTH_TOKEN }}

    - name: 4. Build and Push Docker Image
      run: |
        REPO_NAME=$(echo "${{ env.APP_NAME }}/${{ env.FUNCTION_NAME }}" | tr '[:upper:]' '[:lower:]')
        IMAGE_TAG="${{ secrets.OCI_REGION_KEY }}.ocir.io/${{ secrets.OCI_NAMESPACE }}/${REPO_NAME}:${{ github.sha }}"
        echo "FULL_IMAGE_NAME=$IMAGE_TAG" >> $GITHUB_ENV
        docker build -t "$IMAGE_TAG" .
        docker push "$IMAGE_TAG"

    - name: 5a. Ensure Final Route Table Configuration (SGW and NAT)
      run: |
        set -e; SUBNET_DETAILS=$(oci network subnet get --subnet-id "${{ secrets.PRIVATE_SUBNET_OCID }}")
        ROUTE_TABLE_OCID=$(echo "$SUBNET_DETAILS" | jq -r '.data."route-table-id"'); VCN_OCID=$(echo "$SUBNET_DETAILS" | jq -r '.data."vcn-id"')
        VCN_DETAILS=$(oci network vcn get --vcn-id "$VCN_OCID"); VCN_COMPARTMENT_OCID=$(echo "$VCN_DETAILS" | jq -r '.data."compartment-id"')
        SERVICE_GATEWAY_OCID=$(oci network service-gateway list --compartment-id "$VCN_COMPARTMENT_OCID" --vcn-id "$VCN_OCID" --query "data[0].id" --raw-output); if [ -z "$SERVICE_GATEWAY_OCID" ]; then echo "Error: No Service Gateway found" >&2; exit 1; fi
        NAT_GATEWAY_OCID=$(oci network nat-gateway list --compartment-id "$VCN_COMPARTMENT_OCID" --vcn-id "$VCN_OCID" --query "data[0].id" --raw-output); if [ -z "$NAT_GATEWAY_OCID" ]; then echo "Error: No NAT Gateway found" >&2; exit 1; fi
        SERVICE_CIDR_LABEL=$(oci network service list --query "data[?name=='${{ secrets.OCI_SERVICES_NETWORK_NAME }}'].\"cidr-block\" | [0]" --raw-output); if [ -z "$SERVICE_CIDR_LABEL" ] || [ "$SERVICE_CIDR_LABEL" == "null" ]; then echo "Error: Could not find Service CIDR Label" >&2; exit 1; fi
        FINAL_PAYLOAD=$(jq -n --arg sgw_ocid "$SERVICE_GATEWAY_OCID" --arg nat_ocid "$NAT_GATEWAY_OCID" --arg service_cidr "$SERVICE_CIDR_LABEL" '[{"destination": $service_cidr,"destinationType": "SERVICE_CIDR_BLOCK","networkEntityId": $sgw_ocid,"description": "Platform Egress via SGW","routeType": "STATIC"},{"cidrBlock": "0.0.0.0/0","networkEntityId": $nat_ocid,"description": "General Egress via NAT","routeType": "STATIC"}]')
        oci network route-table update --rt-id "$ROUTE_TABLE_OCID" --route-rules "$FINAL_PAYLOAD" --force; echo "Successfully enforced final route table configuration."

    - name: 5b. Create or Update NSG and Enforce Correct Egress Rule    
      run: |
        set -e
        echo "Ensuring NSG '${{ env.NSG_NAME }}' exists and has the correct egress rule..."
        NSG_OCID=$(oci network nsg list --compartment-id "${{ secrets.OCI_COMPARTMENT_OCID }}" --display-name "${{ env.NSG_NAME }}" --query "data[0].id" --raw-output || true)
        
        if [ -z "$NSG_OCID" ]; then
          echo "NSG not found. Creating it..."
          VCN_OCID=$(oci network subnet get --subnet-id "${{ secrets.PRIVATE_SUBNET_OCID }}" | jq -r '.data."vcn-id"')
          NSG_OCID=$(oci network nsg create --compartment-id "${{ secrets.OCI_COMPARTMENT_OCID }}" --vcn-id "$VCN_OCID" --display-name "${{ env.NSG_NAME }}" --query "data.id" --raw-output)
        fi
        echo "NSG_OCID=${NSG_OCID}" >> $GITHUB_ENV

        # --- RECONCILIATION STEP 1: Get all existing rule IDs as a JSON array ---
        # This now correctly formats the output for the 'remove' command.
        EXISTING_RULE_IDS_JSON=$(oci network nsg rules list --nsg-id "$NSG_OCID" --query "data[].id")
        
        # --- RECONCILIATION STEP 2: Remove all existing rules to ensure a clean state ---
        # The check below handles cases where the NSG is new and the command returns an empty array '[]' or null.
        if [ -n "$EXISTING_RULE_IDS_JSON" ] && [ "$EXISTING_RULE_IDS_JSON" != "[]" ] && [ "$EXISTING_RULE_IDS_JSON" != "null" ]; then
            echo "Found existing rules. Removing them to enforce a clean state..."
            # Use 'echo "y" |' to automatically confirm the interactive prompt.
            echo "y" | oci network nsg rules remove --nsg-id "$NSG_OCID" --security-rule-ids "$EXISTING_RULE_IDS_JSON"
            echo "All existing rules removed."
        else
            echo "NSG is empty. No rules to remove."
        fi

        # --- RECONCILIATION STEP 3: Add the single, correct egress rule ---
        SERVICE_CIDR_LABEL=$(oci network service list --query "data[?name=='${{ secrets.OCI_SERVICES_NETWORK_NAME }}'].\"cidr-block\" | [0]" --raw-output)
        
        ADD_RULE_PAYLOAD=$(jq -n \
          --arg dest "$SERVICE_CIDR_LABEL" \
          '[
            {
              "direction": "EGRESS",
              "protocol": "6",
              "isStateless": false,
              "destination": $dest,
              "destinationType": "SERVICE_CIDR_BLOCK",
              "tcpOptions": {
                "destinationPortRange": {
                  "min": 443,
                  "max": 443
                }
              },
              "description": "Allow runtime egress for RP auth (Managed by CI/CD)"
            }
          ]')
        
        echo "Adding definitive egress rule..."
        oci network nsg rules add --nsg-id "$NSG_OCID" --security-rules "$ADD_RULE_PAYLOAD"
        echo "Successfully enforced correct egress rule on NSG."
    - name: 5c. Create or Recreate Function Application with NSG
      run: |
        set -e
        echo "Checking for existing application '${{ env.APP_NAME }}'..."
        APP_OCID=$(oci fn application list --compartment-id ${{ secrets.OCI_COMPARTMENT_OCID }} --display-name "${{ env.APP_NAME }}" --query "data[0].id" --raw-output || true)
        
        CREATE_APP=false
        if [ -z "$APP_OCID" ] || [ "$APP_OCID" == "null" ]; then
          echo "Application not found. It will be created."
          CREATE_APP=true
        else
          echo "Application found. Verifying network configuration..."
          APP_DETAILS=$(oci fn application get --application-id "$APP_OCID" --query "data")
          CURRENT_SUBNET=$(echo "$APP_DETAILS" | jq -r '."subnet-ids"[0]')
          CURRENT_NSG=$(echo "$APP_DETAILS" | jq -r '."network-security-group-ids"[0]')
          if [ "$CURRENT_SUBNET" != "${{ secrets.PRIVATE_SUBNET_OCID }}" ] || [ "$CURRENT_NSG" != "${{ env.NSG_OCID }}" ]; then
            echo "Application has incorrect network config. Recreating it."
            oci fn application delete --application-id "$APP_OCID" --force
            CREATE_APP=true
          else
            echo "Application network config is correct."
          fi
        fi

        if [ "$CREATE_APP" = true ]; then
          echo "Creating application with private subnet and NSG..."
          oci fn application create --compartment-id "${{ secrets.OCI_COMPARTMENT_OCID }}" --display-name "${{ env.APP_NAME }}" --subnet-ids '["${{ secrets.PRIVATE_SUBNET_OCID }}"]' --network-security-group-ids '["${{ env.NSG_OCID }}"]'
        fi

    - name: 6. Create or Update OCI Function
      env:
        DB_SECRET_OCID: ${{ secrets.DB_SECRET_OCID }}
        OCI_NAMESPACE: ${{ secrets.OCI_NAMESPACE }}
      run: |
        APP_OCID=$(oci fn application list --compartment-id ${{ secrets.OCI_COMPARTMENT_OCID }} --display-name "${{ env.APP_NAME }}" --query "data[0].id" --raw-output || true)
        FUNCTION_OCID=$(oci fn function list --application-id "$APP_OCID" --display-name "${{ env.FUNCTION_NAME }}" --query "data[0].id" --raw-output || true)
        JSON_CONFIG=$(jq -n --arg db_secret "$DB_SECRET_OCID" --arg namespace "$OCI_NAMESPACE" '{"DB_SECRET_OCID": $db_secret, "OCI_NAMESPACE": $namespace}')
        if [ -z "$FUNCTION_OCID" ] || [ "$FUNCTION_OCID" == "null" ]; then
          oci fn function create --application-id "$APP_OCID" --display-name "${{ env.FUNCTION_NAME }}" --image "${{ env.FULL_IMAGE_NAME }}" --memory-in-mbs 1024 --timeout-in-seconds 120 --config "$JSON_CONFIG"
        else
          oci fn function update --function-id "$FUNCTION_OCID" --image "${{ env.FULL_IMAGE_NAME }}" --config "$JSON_CONFIG" --force
        fi

    - name: 7. Wait for IAM Propagation
      run: |
        echo "Waiting 60 seconds for IAM service to recognize the new/updated function..."
        sleep 60
        echo "Cooldown complete."