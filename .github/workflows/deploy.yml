
# This workflow is for Continuous Deployment (CD). It automatically deploys
# the application code to an existing OCI Function whenever changes are
# pushed to the 'main' branch. It does NOT manage the underlying infrastructure.
name: 'Deploy Application Code'

on:
  push:
    branches:
      - main

env:
  APP_NAME: "app-rag"
  FUNCTION_NAME: "rag-ingestor"

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
    # Step 1: Get the source code.
    - name: 1. Check out repository
      uses: actions/checkout@v4

    # Step 2: Authenticate the runner with the OCI API. This allows the runner
    # to send commands like 'oci fn function update'.
    - name: 2. Configure OCI CLI
      run: |
        pip install --upgrade oci-cli jq
        mkdir -p ~/.oci
        printf "%s\n" "${{ secrets.OCI_PRIVATE_KEY_CONTENT }}" > ~/.oci/oci_api_key.pem
        echo "[DEFAULT]" > ~/.oci/config
        echo "user=${{ secrets.OCI_USER_OCID }}" >> ~/.oci/config
        echo "fingerprint=${{ secrets.OCI_FINGERPRINT }}" >> ~/.oci/config
        echo "tenancy=${{ secrets.OCI_TENANCY_OCID }}" >> ~/.oci/config
        echo "region=${{ secrets.OCI_REGION }}" >> ~/.oci/config
        echo "key_file=~/.oci/oci_api_key.pem" >> ~/.oci/config
        chmod 600 ~/.oci/oci_api_key.pem ~/.oci/config

    # Step 3: Authenticate the Docker client with the OCI Container Registry (OCIR).
    # This is a separate authentication needed to push the container image.
    - name: 3. Log in to OCI Container Registry (OCIR)
      uses: docker/login-action@v3
      with:
        registry: ${{ secrets.OCI_REGION_KEY }}.ocir.io
        username: ${{ secrets.OCIR_USERNAME }}
        password: ${{ secrets.OCIR_AUTH_TOKEN }}

    # Step 4: Build the container image and push it to the registry.
    # The image is tagged with the unique Git commit SHA for versioning.
    - name: 4. Build and Push Docker Image
      run: |
        REPO_NAME=$(echo "${{ env.APP_NAME }}/${{ env.FUNCTION_NAME }}" | tr '[:upper:]' '[:lower:]')
        IMAGE_TAG="${{ secrets.OCI_REGION_KEY }}.ocir.io/${{ secrets.OCI_NAMESPACE }}/${REPO_NAME}:${{ github.sha }}"
        # This makes the IMAGE_TAG variable available to subsequent steps' shells.
        echo "FULL_IMAGE_NAME=$IMAGE_TAG" >> $GITHUB_ENV
        docker build -t "$IMAGE_TAG" .
        docker push "$IMAGE_TAG"

    # Step 5: Tell OCI Functions to update the running function to use the new image.
    # This step will FAIL if the function does not already exist.
    - name: 5. Update Function Image and Enforce Configuration
      env:
        # These secrets are passed to the function as runtime environment variables.
        OCI_USER_OCID: ${{ secrets.OCI_USER_OCID }}
        OCI_FINGERPRINT: ${{ secrets.OCI_FINGERPRINT }}
        OCI_TENANCY_OCID: ${{ secrets.OCI_TENANCY_OCID }}
        OCI_REGION: ${{ secrets.OCI_REGION }}
        OCI_PRIVATE_KEY_CONTENT: ${{ secrets.OCI_PRIVATE_KEY_CONTENT }}
        DB_SECRET_OCID: ${{ secrets.DB_SECRET_OCID }}
        OCI_NAMESPACE: ${{ secrets.OCI_NAMESPACE }}
        TARGET_BUCKET_NAME: ${{ secrets.TARGET_BUCKET_NAME }}
        OCI_COMPARTMENT_OCID: ${{ secrets.OCI_COMPARTMENT_OCID }}
      run: |
        echo "Looking up function OCID..."
        APP_OCID=$(oci fn application list --compartment-id $OCI_COMPARTMENT_OCID --display-name "${{ env.APP_NAME }}" --query "data[0].id" --raw-output)
        FUNCTION_OCID=$(oci fn function list --application-id "$APP_OCID" --display-name "${{ env.FUNCTION_NAME }}" --query "data[0].id" --raw-output)
        if [ -z "$FUNCTION_OCID" ] || [ "$FUNCTION_OCID" == "null" ]; then
          echo "FATAL: Function not found. Run the 'Provision' workflow manually first." >&2
          exit 1
        fi

        echo "Enforcing function configuration..."
        B64_KEY=$(echo "$OCI_PRIVATE_KEY_CONTENT" | base64 -w 0)
        JSON_CONFIG=$(jq -n \
          --arg user_ocid "$OCI_USER_OCID" \
          --arg fingerprint "$OCI_FINGERPRINT" \
          --arg tenancy_ocid "$OCI_TENANCY_OCID" \
          --arg region "$OCI_REGION" \
          --arg b64_key_content "$B64_KEY" \
          --arg db_secret "$DB_SECRET_OCID" \
          --arg namespace "$OCI_NAMESPACE" \
          --arg bucket_name "$TARGET_BUCKET_NAME" \
          '{
            "OCI_USER_OCID": $user_ocid,
            "OCI_FINGERPRINT": $fingerprint,
            "OCI_TENANCY_OCID": $tenancy_ocid,
            "OCI_REGION": $region,
            "OCI_PRIVATE_KEY_B64": $b64_key_content,
            "DB_SECRET_OCID": $db_secret,
            "OCI_NAMESPACE": $namespace,
            "TARGET_BUCKET_NAME": $bucket_name
          }')

        echo "Updating function with new image..."
        # --- THIS IS THE CORE DEPLOYMENT COMMAND ---
        # It uses the shell variable '$FULL_IMAGE_NAME' set in the previous step.
        oci fn function update --function-id "$FUNCTION_OCID" --image "$FULL_IMAGE_NAME" --config "$JSON_CONFIG" --force

    # Step 6: A brief pause to allow cloud services to propagate the changes.
    - name: 6. Wait for Propagation
      run: |
        echo "Waiting 30 seconds for changes to propagate..."
        sleep 30
        echo "Cooldown complete."